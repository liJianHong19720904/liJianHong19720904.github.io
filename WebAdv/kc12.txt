1.title
  From Object to DOM（探索篇：内存对象和Web页文档对象模型）
2.introduction
  对象这种数据结构可以把许多简单数据组合起来，形成人们更易理解和管理的信息集合。前面我们尝试了JavaScript建立对象的几种方法，但用这些方法建立的对象存在于何处？这些对象与Web页面有关系吗？本课深刻讨论这些问题。
  代码创建的对象，不管是系统内置对象，还是自定义对象，如同其他的数字数据一样，都存在于计算机内存中，因此对象都是内存对象，可以为代码提供高速的访问，在开发者的Console命令行中，可以用Console.log输出查看这些对象信息。
  Web页提供了基于DOM技术的丰富的UI生成能力，本课我们思考如何把这类内存对象，用Web元素的形式表现在Web页面上，形成一种更加内涵丰富的输出形式。本课实践中，我们利用五个案例，同时演示了创建内存对象和Web页的DOM对象，再通过设计一个逻辑，把内存对象和Web页的DOM对象关联起来。最后，在Web页面上把DOM对象渲染出来，似乎我们就实现了把抽象的内存对象输出在Web页面了，这是实践应用软件建模的初步思想。

3.keyword
  width:20%; ，height:20%; ， display:inline-block; ， background-color:rgba(0,0,0,0.1); ， document.createElement('div')  ，document.createElement('p')  ，父元素.appendChild(子元素) ，div.style.borderColor ，div.style.height  ，内存对象.divDom.style.left  ，内存对象.divDom.style.display 。 
	
4.project
  <a src=objDom-1.html  title=向Web页动态添加元素(代码无法运行)>本例演示用JavaScript语言在Web页，用代码动态（在程序运行的时刻，on the fly）向Web页添加元素对象。
  <a src=objDom-2.html title=向Web页动态添加元素(代码可以运行)>本例稍微把Dom操作的代码片段移动位置，就实现在Web页生成100个矩形，且不会有报错信息，需要从Web页内存模型建立的角度理解和分析这种现象。
  <a src=objDom-3.html title=用Web的DOM技术创建可视化信息>本例在构造函数创建对象模型基础上，利用Web的DOM技术展现内存信息的可视化外观！
  <a src=objDom-4.html title=引入点击事件>本例用构造函数创建内存对象，结合CSS让利用DOM元素实现随意定位，最后再利用onclick点击事件来逐一实现对象再网页上的移动！本例需要理解函数中的this关键字，在函数执行的不同上下文中，this所代表的也完全不同。这点对于多数开发者而言，可能难以真正理解，需要一段时间学习才能领悟。
  <a src=objDom-5.html title=异步事件和DOM元素的动画>本例利用onmouseover事件触发对象的goOut方法，实现dom元素移动动画，为实现异步代码能获取变量不断变化的数据，我们引入了函数闭包概念和js变量作用域的lexical语法。另外，本例this的运用和对象指向传递，对其理解需要比较深的功力，因此本例仅供学有余力的学习者参考，普通开发者能大致看懂代码即可，无需掌握编写。
5.reading

Understanding the DOM is key to being able to manipulate the text or HTML in a web page. Using the DOM, you can create animations, update data without refreshing web pages, move objects around in a browser, and much more! 
The Document Object Model is the interface for JavaScript to talk to and work with HTML documents inside of browser windows. The DOM can be visualized as an inverted tree, with each part of the HTML document branching off of its containing part.
A DOM tree is made up of individual components, called nodes. The main node, from which every other node springs, is called the document node. The node under the document node is the root element node. For HTML documents, the root node is HTML. After the root  node, every element, attribute, and piece of content in the document is represented by a node in the tree that comes from another node in the tree.
Manipulating Nodes  .  Once we’ve accessed a node by using one of the methods discussed previously, the DOM gives us several built-in methods for manipulating those elements, their attributes, and their contents. 
Manipulating Nodes textContent  .  Node.textContent  gives us  a simple methods for accessing and changing the text and markup inside an element.  Let’s say we need a quick way of adding a paragraph of text to the first element on our page with a class of intro: var introDiv = document.getElementsByClassName("intro");  introDiv[0].textContent = "This is our intro text";  The second statement here adds the content of the string to introDiv (an element with the class value “intro”) as a real live element. 
Manipulating Nodes Style . The DOM also allows you to add, modify, or remove a CSS style from an element by using the style property. It works similarly to applying a style with the inline style attribute. The individual CSS properties are available as properties of the style property. I bet you can figure out what these statements are doing by using your new CSS and DOM know-how: document.getElementById("intro").style.color = "#fff";  document.getElementById("intro").style.backgroundColor = "#f58220"; In JavaScript and the DOM, property names that are hyphenated in CSS (such as background-color and border-top-width) become camel case (backgroundColor and borderTopWidth, respectively) so the “–” character isn’t mistaken for an operator.

Adding and Removing Elements
So far, we’ve seen examples of getting and setting nodes in the existing document. The DOM also allows developers to change the document structure itself by adding and removing nodes on the fly. We’ll start out by creating new nodes, which is fairly straightforward, and then we’ll see how we add the nodes we’ve created to the page. The methods shown here are more surgical and precise than adding content with innerHTML or textContent. While we’re at it, we’ll remove nodes, too. 
To create a new element, use the aptly named createElement() method. This function accepts a single argument: the element to be created. Using this method is a little counterintuitive at first because the new element doesn’t appear on the page right away. Once we create an element in this way, that new element remains floating in the JavaScript ether until we add it to the document. Think of it as creating a reference to a new element that lives purely in memory—something that we can manipulate in JavaScript as we see fit, and then add to the page once we’re ready:  var newDiv = document.createElement("div");   If we want to enter text into either an element we’ve created or an existing element on the page, we can call the createTextNode() method. To use it, provide a string of text as an argument, and the method creates a DOM-friendly version of that text, ready for inclusion on the page. Like createElement(), this creates a reference to the new text node that we can store in a variable and add to the page when the time comes: var ourText = document.createTextNode("This is our text.");  So we’ve created a new element and a new string of text, but how do we make them part of the document? Enter the appendChild() method. This method takes a single argument: the node you want to add to the DOM. You call it on the existing element that will be its parent in the document structure. 
To paraphrase my mother, “We brought these elements into this world, and we can take them out again.” You remove a node or an entire branch from the document tree with the removeChild() method. The method takes one argument, which is the node you want to remove. Remember that the DOM thinks in terms of nodes, not just elements, so the child of an element may be the text (node) it contains, not just other elements. Like  appendChild(), the removeChild() method is always called on the parent element of the element to be removed (hence, “remove child”). That means we’ll need a reference to both the parent node and the node we’re looking to remove.
